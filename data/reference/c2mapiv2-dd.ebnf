(* TODO: Allow multiple recipient addresses in line. *)
(* TODO: Allow different ways to specify recipient addresses in one api call. *)
(* TODO: Should we define responses in the Data Dictionary *)

(* In this version need to change all PascalCase to camelCase. *)

(* TEST DEPLOYMENT: 2025-09-18 - Testing two-repo architecture deployment to both Postman workspaces *)

(***********************************)
(*        USE CASE DEFINITIONS        *)
(***********************************)

(*
  Use Case 1: I have a document, recipient addresses & a job template.
  Endpoint: POST /jobs/single-doc-job-template
submitSingleDocWithTemplateParams =
      documentSourceIdentifier
    + [ { recipientAddressSource } ]
    + jobTemplate
    + [ paymentDetails ]
    + [ tags ] ;
*)

(* 
  Use Case 1: I have a single document, some recipients, and a job template.
  Endpoint: POST /jobs/single-doc-job-template
submitSingleDocWithTemplateParams =
      ( ("TEMPLATE" | documentSourceIdentifier) + { recipientAddressSource }
      | ("TEMPLATE" | { recipientAddressSource }) + documentSourceIdentifier
      | (documentSourceIdentifier + { recipientAddressSource}) )
    + jobTemplate
    + paymentDetails
    + [ tags ] ;
*)

submitSingleDocWithTemplateParams =
      ( documentSourceIdentifier
      | { recipientAddressSource }
      | (documentSourceIdentifier + { recipientAddressSource}) )
    + jobTemplate
    + paymentDetails
    + [ tags ] ;

(*
  Use Case 2: I have multiple documents each to different recipient addresses & a job template.
  Endpoint: POST /jobs/multi-docs-job-template
*)
submitMultiDocWithTemplateParams =
      { documentSourceIdentifier + recipientAddressSource }
    + jobTemplate
    + paymentDetails
    + [ tags ] ;

(* 
  Use Case 3: I want to merge multiple documents, send them to a single recipient, and use a job template.
  Endpoint: POST /jobs/multi-doc-merge-job-template
mergeMultiDocWithTemplateParams = 
      documentsToMerge 
    + [ ("TEMPLATE" | recipientAddressSource) ] 
    + jobTemplate 
    + paymentDetails 
    + [ tags ] ;
*)


(*
  Use Case 3: I want to merge multiple documents, send them to a single recipient, and use a job template.
  Endpoint: POST /jobs/multi-doc-merge-job-template
*)
mergeMultiDocWithTemplateParams =
      documentsToMerge
    + recipientAddressSource
    + jobTemplate
    + paymentDetails
    + [ tags ] ;

(* 
  Use Case 4: I have a document and multiple recipient addresses.
  Endpoint: POST /jobs/single-doc
  Sends one document to multiple recipients. Common for bulk messaging, newsletters, or notices.
*)
singleDocJobParams = 
      documentSourceIdentifier 
    + { recipientAddressSource }            (* One or more recipients, each defined or referenced *)
    + jobOptions                            (* Layout, print, delivery preferences *)
    + paymentDetails                    (* Optional billing info, depending on configuration *)
    + [ tags ] ;                            (* Optional metadata tags, e.g., campaign identifiers *)

(* 
  Use Case 5: I have multiple documents; each goes to a different recipient address.
  Endpoint: POST /jobs/multi-doc
  Perfect for personalized mailing, where each recipient gets a different file.
*)
submitMultiDocParams = 
      { documentSourceIdentifier + recipientAddressSource } 
    + jobOptions 
    + paymentDetails
    + [ tags ] ;

(*
  Use Case 6: I want to merge multiple documents into one document and send it to a single recipient.
  Endpoint: POST /jobs/multi-doc-merge
  Ideal for assembling packets (e.g., onboarding kits) before delivery.
*)
mergeMultiDocParams = 
      documentsToMerge 
    + recipientAddressSource 
    + paymentDetails
    + [ tags ] ;

documentsToMerge = { documentSourceIdentifier };        (* One or more documents to be merged in order *)

(* 
  Use Case 7: I have a big PDF to send to different recipients.
  Endpoint: POST /jobs/single-pdf-split
  Splits a multi-page PDF and assigns different recipients to each range.
*)
splitPdfParams = 
      documentSourceIdentifier 
    + { pageRange + { recipientAddressSource } } (* Multiple ranges and recipients.  Mulitple recipients allowed per pdf. *) 
    + paymentDetails 
    + [ tags ] ;

pageRange = startPage + endPage ;
startPage = integer ;
endPage   = integer ;

(* 
  Use Case 8: I have a big PDF with serialized documents and the related recipient addresses are in the PDF.
  Endpoint: POST /jobs/single-pdf-split-addressCapture
  Enables automated address extraction from fixed regions inside PDF pages.
*)
splitPdfWithCaptureParams = 
      documentSourceIdentifier 
    + embeddedExtractionSpecs 
    + paymentDetails 
    + [ tags ] ;

embeddedExtractionSpecs = { extractionSpec } ;

extractionSpec = startPage + endPage + addressRegion ;

(* Placehoder *)
addressRegion = x + y + width + height + pageOffset ; (* Not sure how the addesses will be located.  This is a placeholder *)

(* Placeholders *)
x = number ; (* New as of 07082025 *)
y = number ; (* New as of 07082025 *)
width = number ; (* New as of 07082025 *)
height = number ; (* New as of 07082025 *)
pageOffset = integer ; (* New as of 07082025 *)

(* 
  Use Case 9: I have multiple PDFs and the addresses are in each PDF.
  Endpoint: POST /jobs/multi-pdf-address-capture
  Suitable for cases where PDFs are pre-batched and each file contains its own embedded address block.
*)
multiPdfWithCaptureParams = 
      addressCapturePdfs 
    + paymentDetails
    + [ tags ] ;

addressCapturePdfs = { addressListPdf } ;

addressListPdf = 
      documentSourceIdentifier 
    + addressListRegion 
    + [ delimiter ] 
    + [ tags ] ;

addressListRegion = tbd ;

tbd = string ;

(* Not user a delimeter is used *)
delimiter = string ;   (* Character used to separate multiple addresses inside the PDF *)

(********************************)
(*        CORE FIELD DEFINITIONS         *)
(********************************)

(* 
  DocumentSourceIdentifier determines the origin of a document being submitted to the system.
  Supports various methods depending on upload workflows:
  - Direct reference to a previously uploaded document
  - External URLs for remote-hosted documents
  - Complex identifiers for zip archives and multipart uploads
*)
documentSourceIdentifier = 
      documentId                          (* Unique ID for a document previously uploaded and stored in the system *)
    | externalUrl                         (* Full HTTP/HTTPS URL pointing to a downloadable document file *)
    | (uploadRequestId + documentName)    (* Refers to a document uploaded in a session identified by uploadRequestId *)
    | (uploadRequestId + zipId + documentName) (* Used for zip bundles submitted within a session; identifies file inside zip *)
    | (zipId + documentName) ;            (* Points to a specific document inside an archived zip, without session context *)

(* 
  Defines a mutually exclusive source for recipient addresses:
  - Either a fully inline address
  - A reference to a preloaded address list
  - Or a reference to a saved address
*)
(*
    exactlyOneNewAddress
    | exactlyOneListId
    | exactlyOneId ;

exactlyOneNewAddress = recipientAddress ;
exactlyOneListId     = addressListId ;
exactlyOneId         = addressId ;
*)

recipientAddressSource = 
    recipientAddress
    | addressListId
    | addressId ;

(*
  Comprehensive recipient address block.
  Required fields ensure mailable accuracy; optional fields enhance personalization or flexibility.
*)
recipientAddress = 
      firstName + lastName                (* Full recipient name, split into first and last *)
    + address1                            (* Primary delivery line (e.g., 123 Main St) *)
    + city + state + zip + country        (* Required to resolve destination geography *)
    + [ nickName ]                        (* Optional informal salutation or identifier *)
    + [ address2 ] + [ address3 ]         (* Secondary address lines, often used for Apt/Suite/Bldg *)
    + [ phoneNumber ] ;                   (* Optionalâ€”may support SMS fallback or multi-channel routing *)

(* 
  Represents the physical presentation and mailing behavior of the job.
  This block directly affects pricing, rendering style, and postage.
*)
jobOptions = 
      documentClass                       (* BusinessLetter or PersonalLetter classification *)
    + layout                              (* Portrait or Landscape document orientation *)
    + mailclass                           (* Postal service level (e.g., First Class, Priority) *)
    + paperType                           (* Size or media type, such as "letter" or "postcard" *)
    + printOption                         (* Print output mode: full-color, grayscale, or none *)
    + envelope ;                          (* Envelope format or whether one is used at all *)

(* 
  Payment options allow flexibility across B2B, B2C, and credit-based platforms.
  Some methods require additional nested structures.
*)
paymentDetails =
      creditCardPayment
    | invoicePayment
    | achPayment
    | userCreditPayment
    | applePayPayment
    | googlePayPayment ;

applePayPayment =
      "APPLE_PAY"                       (* Immediate payment using Apple Pay *)
    + applePaymentDetails ;

googlePayPayment =
      "GOOGLE_PAY"                       (* Immediate payment using Google Pay *)
    + googlePaymentDetails ;

creditCardPayment =
      "CREDIT_CARD"                       (* Immediate payment using a credit card *)
    + creditCardDetails ;

invoicePayment =
      "INVOICE"                           (* Billed after fulfillment using invoice number *)
    + invoiceDetails ;

achPayment =
      "ACH"                               (* Automated Clearing House for direct debit *)
    + achDetails ;

userCreditPayment =
      "USER_CREDIT"                       (* Deduct from user account balance *)
    + creditAmount ;

(* Credit card structure required for "creditCard" billing *)
creditCardDetails =
      cardType
    + cardNumber
    + expirationDate
    + cvv ;

invoiceDetails =
      invoiceNumber
    + amountDue ;

achDetails =
      routingNumber
    + accountNumber
    + checkDigit ;

creditAmount =
      amount
    + currency ;

applePaymentDetails = "TBD" ;

googlePaymentDetails = "TBD" ;

(* Value field types *)
currency = "USD" | "EUR" | "GBP" | "CAD" | "AUD" ;
amount = number ;

(* Leaf fields *)
cardNumber       = string ;
cardType         = string ;
expirationDate   = month + year ;
month            = integer ;
year             = integer ;
cvv              = integer ;
routingNumber    = string ;
accountNumber    = string ;
checkDigit       = integer ;
invoiceNumber    = string ;
amountDue        = number ;

jobTemplate          = string;
addressListId        = id; (* New as of 07082025 *)
addressId            = id;
documentName         = string ;
documentId           = id; (* New as of 07082025 *)
externalUrl          = string ; (* New as of 07082025 *)
uploadRequestId      = id;
zipId                = id;
firstName            = string ;
lastName             = string ;
nickName             = string ;
address1             = string ;
address2             = string ;
address3             = string ;
city                 = string ;
state                = string ;
country              = string ;
zip                  = string ;
phoneNumber          = string ;
tags                 = { tags } ; (* New as of 07102025 *)
tag                  = string ;  (* Optional metadata tags for analytics or categorization *)

id = integer;

(*************************)
(*       ENUM DEFINITIONS     *)
(*************************)

cardType = 
      "visa" 
    | "mastercard" 
    | "discover" 
    | "americanExpress" ;

documentFormat = 
      "pdf" | "doc" | "docx" | "pub" | "ppt" | "pptx" | "png" | "jpeg" | "odt" ;

printOption = 
      "none" | "color" | "grayscale" ;

envelope = 
      "flat" | "windowedFlat" | "letter" | "legal" | "postcard" ;

paperType = 
      "letter" | "legal" | "postcard" ;

layout = 
      "portrait" | "landscape" ;

mailclass = 
      "firstClassMail" | "priorityMail" | "largeEnvelope" ;

documentClass = 
      "businessLetter" | "personalLetter" ;


(****************************)
(*      JOB TEMPLATE BLOCK      *)
(****************************)

(*
jobTemplate = 
      jobTemplateId 
    | fullJobTemplate 
    | jobTemplateName ;
??? 
jobTemplateName = string ;
*)

(* 
  Full inlined template with config and optional doc/recipient info.
  Supports overrides and repeatable use.
  What about jobTemplateName along with JobTemplateId? 
fullJobTemplate = 
      jobTemplateId +
      [ { documentSourceIdentifier } ] |
    [ { recipientAddressSource } ] ;
*)

(*
jobTemplate = jobTemplateId +
              [ { documentSourceIdentifier } ] |
              [ { recipientAddressSource } ] ;

jobTemplateId = id;
*)

(*
      Maybe make this change?
      multiDocRecipientPair = documentSourceIdentifier + recipientAddressSource ;
      submitMultiDocParams = { multiDocRecipientPair } + jobOptions ...
*)

(*
      TODO: Does jobTemplate really inlcude addressList
      If addressList is passed within the template (rather than externally provided during submission), 
      it implies tight coupling of content + recipients, which may be limiting. Might consider
      breaking this apart:

      jobTemplate = jobTemplateId + name + jobOptions + document
      jobTemplateWithAddressList = jobTemplate + addressList

      TODO: Note that jobOptions are in both jobSpecs and jobTemplate.
      Also, is document contains documentId and documentSource 
      can be a docoumentId.

      In separate document we should analyze jobTemplate, jobSpecs, jobSpecsTemplate
      and where they are referenced, because of possibility of the duplication of
      some elements.
*)
